/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
'use strict';
var messages_1 = require('./messages');
var messageReader_1 = require('./messageReader');
var messageWriter_1 = require('./messageWriter');
exports.ERROR_NOT_HANDLED = 0x100;
exports.ERROR_HANDLER_FAILURE = 0x101;
exports.ERROR_CUSTOM = 0x1000;
function connect(inputStream, outputStream, logger, client) {
    if (client === void 0) { client = false; }
    var protocolWriter = new messageWriter_1.MessageWriter(outputStream);
    var sequenceNumber = 0;
    var requestHandlers = Object.create(null);
    var responseHandlers = Object.create(null);
    var eventHandlers = Object.create(null);
    var connection = {
        sendEvent: function (type, body) {
            var eventMessage = {
                type: messages_1.Message.Event,
                seq: sequenceNumber++,
                event: type.event,
                body: body
            };
            protocolWriter.write(eventMessage);
        },
        onRequest: function (type, handler) {
            requestHandlers[type.command] = handler;
        },
        onEvent: function (type, handler) {
            eventHandlers[type.event] = handler;
        },
        dispose: function () {
            // TODO
        }
    };
    if (client) {
        connection.sendRequest = function (type, args) {
            return new Promise(function (resolve, reject) {
                var requestMessage = {
                    type: messages_1.Message.Request,
                    seq: sequenceNumber++,
                    command: type.command,
                    arguments: args
                };
                responseHandlers[String(requestMessage.seq)] = { resolve: resolve, reject: reject };
                protocolWriter.write(requestMessage);
            });
        };
    }
    inputStream.on('end', function () { return outputStream.end(); });
    inputStream.on('close', function () { return outputStream.end(); });
    function handleRequest(requestMessage) {
        function reply(response) {
            var result = response;
            result.type = messages_1.Message.Response;
            result.seq = sequenceNumber++;
            result.request_seq = requestMessage.seq;
            result.command = requestMessage.command;
            protocolWriter.write(result);
        }
        var requestHandler = requestHandlers[requestMessage.command];
        if (requestHandler) {
            try {
                var handlerResult = requestHandler(requestMessage.arguments);
                var promise = handlerResult;
                if (!promise) {
                    reply({ success: false, message: "Handler " + requestMessage.command + " failure", code: exports.ERROR_HANDLER_FAILURE });
                }
                else if (promise.then) {
                    promise.then(function (responseContent) {
                        reply(responseContent);
                    }, function (error) {
                        if (messages_1.isFailedResponse(error)) {
                            reply(error);
                        }
                        else if (error && messages_1.isString(error.message)) {
                            reply({ success: false, message: error.message, code: exports.ERROR_HANDLER_FAILURE });
                        }
                        else {
                            reply({ success: false, message: 'Request failed unexpectedly.', code: exports.ERROR_HANDLER_FAILURE });
                        }
                    });
                }
                else {
                    reply(handlerResult);
                }
            }
            catch (error) {
                if (error && messages_1.isString(error.message)) {
                    reply({ success: false, message: error.message, code: exports.ERROR_HANDLER_FAILURE });
                }
                else {
                    reply({ success: false, message: 'Request failed unexpectedly.', code: exports.ERROR_HANDLER_FAILURE });
                }
            }
        }
        else {
            reply({ success: false, message: "Unhandled command " + requestMessage.command, code: exports.ERROR_NOT_HANDLED });
        }
    }
    function handleResponse(responseMessage) {
        var responseHandler = responseHandlers[String(responseMessage.request_seq)];
        if (responseHandler) {
            responseHandler.resolve(responseMessage);
            delete responseHandlers[String(responseMessage.request_seq)];
        }
    }
    function handleEvent(eventMessage) {
        var eventHandler = eventHandlers[eventMessage.event];
        if (eventHandler) {
            try {
                eventHandler(eventMessage.body);
            }
            catch (error) {
                if (error.message) {
                    logger.error("Event handler '" + eventMessage.event + "' failed with message: " + error.message);
                }
                else {
                    logger.error("Event handler '" + eventMessage.event + "' failed unexpectedly.");
                }
            }
        }
    }
    var callback;
    if (client) {
        callback = function (message) {
            if (message.type === messages_1.Message.Response) {
                handleResponse(message);
            }
            else if (message.type === messages_1.Message.Event) {
                handleEvent(message);
            }
        };
    }
    else {
        callback = function (message) {
            if (message.type === messages_1.Message.Request) {
                handleRequest(message);
            }
            else if (message.type === messages_1.Message.Event) {
                handleEvent(message);
            }
        };
    }
    new messageReader_1.MessageReader(inputStream, callback);
    return connection;
}
function connectWorker(inputStream, outputStream, logger) {
    return connect(inputStream, outputStream, logger);
}
exports.connectWorker = connectWorker;
function connectClient(inputStream, outputStream, logger) {
    return connect(inputStream, outputStream, logger, true);
}
exports.connectClient = connectClient;
